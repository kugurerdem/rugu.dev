<html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Uğur Erdem Seyfi"><link rel=stylesheet href="/style.css?v=1721692800"><title>Switching from Arch to NixOS |
rugu</title><script data-goatcounter=https://stats.rugu.dev/count async src=//stats.rugu.dev/count.js></script></head><body><nav><div class=menu><a href=/en>Home </a><a href=/en/blog>Blog </a><a href=/en/about>About</a></div><div class=languages><a href=/en style=color:#000>en </a><span>| </span><a href=/tr>tr</a></div></nav><div class=master-container><article><div class=page><h1>Switching from Arch to NixOS</h1><i>Written at 2024-07-23</i><div>Discussions:<a href="https://news.ycombinator.com/item?id=41066431" target=_blank> (hackernews)</a></div><hr><p>I’ve switched my desktop computer environment from Arch Linux to NixOS and used
it for about a month. I want to share my migration experience in case it might
interest or even help others.</p><p>I also want to thank my friends <a href=https://github.com/onsah>Onur</a> and
<a href=https://github.com/mk-nlp>Mert</a> for encouraging me to switch to NixOS and
providing help.</p><h1 id=why-migrate-from-arch-in-the-first-place>Why Migrate from Arch in the first place?</h1><p>As someone who likes playing with tools to understand how they work as well as
to match my preferences and ergonomic choices, I find myself frequently changing many
configurations on my system. However, it didn&rsquo;t take long for me to realize
that I need a system to save and possibly automate these configuration
processes to save time in the future.</p><p>A common solution is to create a git repository, often called &ldquo;dotfiles,&rdquo; where
you can store your configurations and changes. This approach helps you avoid
repeating the process of configuring the same stuff over and over when
switching to new host machines. You turn your home folder into a repository
itself by initializing git directly inside of it, set the remote address, and
pull the content. You can check out what my dotfiles looked like before
switching to NixOS <a href=https://github.com/kugurerdem/legacy-dotfiles>here</a>.</p><p>Yet, even with this &ldquo;dotfiles&rdquo; approach there are some problems:</p><ul><li><p>It&rsquo;s very easy to forget to add some configuration files from your computer
to the repo because, in a typical Linux setup, these files are often
scattered in different locations, and unstaged changes can be easily
overlooked. This is especially true for the home directory, where there are
many unstaged files by default, making it easier to miss the ones you want to
stage. I&rsquo;ve had several instances where I realized I was missing some
configuration files from my old computer in the Git repo after formatting my
PC.</p></li><li><p>Your dotfiles are likely to become more complex over time, requiring you to
document how to configure certain aspects to avoid confusion the next time
you set up your environment.</p></li><li><p>Even if your dotfiles repo is perfect, there&rsquo;s no guarantee your system will
work the same when you rebuild it. Changes might have occurred to some of the
packages that your dotfiles repo relies on. As a result, you might encounter
issues regarding package upgrades or even conflicts. This problem isn&rsquo;t
specific to rebuilding systems from a dotfiles repo but also affects regular
users who just want to just update their systems.</p></li></ul><p>In addition to these problems mentioned, although not very often, I would
encounter situations in Arch Linux where I had to look up an error message, a
specific bug, or a non-backward compatible update for some of the apps I use.
Why? Because a system update broke something! While this may not seem like a
big problem, it can be very inconvenient if you&rsquo;re in a hurry to get a job
done. In these kind of situations, I often had to either fix the problem
immediately or ignore it for a while and fix it later. Rolling back to the
state of my computer before the system update and postponing the task of
addressing the issue introduced by the update was not an option.</p><p>This was the moment when I remembered that the tools (Nix and NixOS) my friends
had been recommending could be useful to me.</p><h1 id=what-is-nixnixos>What is Nix/NixOS?</h1><p>In essence, Nix is a package manager (there&rsquo;s also a programming language
called Nix, which can sometimes be confusing). What sets Nix apart from its
alternatives is the way it manages packages and much more, including your home
folder. It is designed to provide reliable and reproducible package management
by isolating packages from each other in a smart way, preventing issues like
dependency conflicts. It also allows users to configure their computers using
its configuration files, through its programming language. So, you&rsquo;re not
limited to downloading specific versions of packages with their dependencies,
but you can also configure other files on your computer, such as your dotfiles.</p><p>NixOS, on the other hand, is a Linux distribution that uses Nix as its default
package manager. It integrates Nix&rsquo;s features to manage the entire system at
both the system and user levels.</p><p>To stay within the scope of this essay, which is to share my Nix and NixOS
experiences rather than explain their inner workings, I&rsquo;ll stop here. However,
if you&rsquo;re curious to learn more, I found <a href=nix.dev>nix.dev</a> and
<a href=nixos.wiki>nixos.wiki</a> particularly helpful for learning more about Nix and NixOS.</p><h1 id=the-learning-curve-and-initial-trial>The Learning Curve and Initial Trial</h1><p>Since NixOS fundamentally provides a much different user experience than most
of the other Linux distributions. I thought it would be wiser to first try
NixOS in a VM instead of directly trying to figure out stuff after installing
the distro on my host machine.</p><p>I can confidently say that during this period of testing NixOS on a VM, I had
more troubles related to <code>QEMU</code> and network bridging than problems related to
understanding how Nix works. The same goes for the installation process as
well, for some reason <code>Ventoy</code> did not work properly with the NixOS iso image
while formatting the disk with <code>dd</code> just worked fine.</p><p>My initial goal was to make the VM I was running function exactly like my host
machine. This way, once I got NixOS working as intended in the VM, I could
replicate the setup on my host machine. I just needed to copy the configuration
files from the VM to the host machine and run a few Nix and NixOS commands. And
this was exactly what happened when I switched to my host machine. Easy peasy.
:)</p><p>In the end, it took me around 4-5 days, working 2-3 hours each day, to learn
Nix and NixOS and replicate about 95% of my Arch dotfiles in the VM. When I
installed NixOS on my host computer, I simply cloned my nix-config repo, ran a
few commands as described, and boom! Everything was set up. :) It was such a
nice experience.</p><h1 id=initial-impressions-and-experience>Initial Impressions and Experience</h1><p>Here are my first impressions after using NixOS for about a month:</p><ul><li><p>At first, it feels like the knowledge you&rsquo;ve gained from using conventional
FHS Linux distros becomes redundant, as you no longer configure programs by
directly modifying their configuration files in the file system. Instead, you
use the settings provided by NixOS and home-manager (a standardized Nix
program that allows users to manage and configure their home environments
through Nix files without root privileges).</p><p>Because most configurations are done through the settings provided by the
packages, it initially seemed like this might prevent users from
understanding what&rsquo;s happening under the hood.</p><p>However, after using NixOS for a while, I realized this was not true. The
abstraction that NixOS packages provide doesn&rsquo;t hide everything from the user
to avoid confusion with irrelevant details. Instead, it offers a way to
configure your environment the Nix way, so the resulting configuration files
are created by Nix.</p><p>Most of the prior knowledge I had about configuring the programs I use was
easily transferable to the NixOS domain. Also, you don&rsquo;t have to configure
every dotfile through Nix. In fact, home-manager allows you to source files
to desired destinations (see the home.file.*.source option for home-manager).</p></li><li><p>The documentation is not in great shape. The Nix wiki is certainly not as
good as the Arch wiki. Sometimes, it&rsquo;s outdated, and other times, it&rsquo;s not
detailed enough. This is why it&rsquo;s very important to learn the Nix programming
language well so you can easily read the options available for a package you
want to install. Once you understand the fundamentals of the Nix programming
language, the code itself becomes the documentation.</p></li><li><p>It is very confusing to have many alternatives for certain tasks. For
example, there are two different ways to install home-manager (standalone
installation vs. system modules), and how you install it affects the way you
interact with it later. Another example is Nix flakes, which are meant to
replace channels (an imperative way of downloading packages) but are still
considered an experimental feature by NixOS.</p><p>To be fair, having to choose between many options is already an issue in
Linux (though many see this as a feature), and NixOS seems to have the same
problem.</p></li><li><p>From my experience so far, most Nix packages are designed to allow
self-contained setups and installations, including plugins. Here are a few
examples:</p><ul><li>When installing Firefox or Chromium browser packages, you can set which
plugins you want to be installed by default.
<a href=https://github.com/kugurerdem/nix-config/blob/963f8a99545fa648e31edf085299fd96802e7d04/home-manager/home.nix#L137>Example</a></li><li>For my default password manager <code>pass</code> (a standard UNIX password
manager), the plugins I wanted to integrate with pass can be defined
through a derivation attribute <code>withExtensions</code>.
<a href=https://github.com/kugurerdem/nix-config/blob/963f8a99545fa648e31edf085299fd96802e7d04/home-manager/home.nix#L52>Example</a></li><li>When installing the Minecraft launcher prismlauncher, you can declare
which JDKs should be available and used by the launcher by simply
overriding one of the package attributes.
<a href=https://github.com/kugurerdem/nix-config/blob/963f8a99545fa648e31edf085299fd96802e7d04/home-manager/home.nix#L81>Example</a></li><li>For Neovim, you can declare which dependencies and plugins you want to
install out of the box using the <code>extraPackages</code> and <code>plugins</code> options of the
home-manager&rsquo;s <code>programs.neovim</code> option.</li></ul><p>These are just a few examples, and I am sure this is a standard for many
other programs. I really like this. Dependencies used only
by certain programs are self-contained within the program that will use them.</p><p>You can even override some of the derivation attributes for the package you
are installing so that it is not installed from the git source repository
defined in the nixpkgs repo, but from your own source repository. I used this
technique to install and set up my window manager dwm using my own git fork
of dwm.
<a href=https://github.com/kugurerdem/nix-config/blob/main/home-manager/dwm.nix#L4>Example</a></p></li><li><p>The configuration files and the nix-config repo I now have are much
more elegant and simpler than my previous dotfiles repo. It&rsquo;s much easier to
organize configurations in a modular way now.</p></li><li><p>The rollback mechanisms that Nix provides (combined with the ease of using
other people&rsquo;s configurations) make trying new things (like different window
managers, desktop environments, programs, or even other people&rsquo;s setups) very
appealing.</p></li><li><p>In Arch, there were a few instances where I had to use additional package
managers like <code>yay</code> to access the AUR (Arch User Repository) alongside the
official Arch repository. I also recall compiling and building some tools,
like <code>fzf</code>, from scratch. I haven&rsquo;t needed to do any of this while using
NixOS.</p><p>Overall, I&rsquo;ve had a better experience with the Nix package manager itself
compared to using pacman and the AUR.</p></li></ul><h1 id=to-conclude>To Conclude</h1><p>In the end, I really think Nix and NixOS are very strong tools for achieving
reliable and reproducible system configurations and package management.
Unfortunately, though, I don&rsquo;t think the benefits I&rsquo;ve gotten in this one month
of using NixOS so far justified the cost I&rsquo;ve initially spent and continue to
spend learning Nix and NixOS.</p><p>But since I currently have no workload and enjoy the learning process, I
don&rsquo;t see a serious problem here.</p><p>Ultimately, whether the benefits of learning a particular technology outweigh
the costs depends on how much you take full advantage of its features. So, I
believe that if I experiment with more setups, try different programs, or start
managing servers with Nix, I will begin to see a better return on this
investment from what I have learned so far. :)</p></div></article><aside class=side><img class=author-image src=/ugur_img.jpg><hr><center><b>Uğur Erdem Seyfi</b></center><hr><div class=icon-container><a href=https://www.linkedin.com/in/ugur-erdem-seyfi target=_blank><img class="icon hover" src=/icons/linkedin.svg>
</a><a href=https://github.com/kugurerdem target=_blank><img class="icon hover" src=/icons/github.svg>
</a><a href="https://news.ycombinator.com/user?id=kugurerdem" target=_blank><img class="icon hover" src=/icons/hackernews.svg>
</a><a href=https://twitter.com/kugurerdem target=_blank><img class="icon hover" src=/icons/twitter.svg>
</a><a href=/en/index.xml target=_blank><img class="icon hover" src=/icons/rss.svg></a></div><hr><div>a software developer with a hacker's attitude, interested in philosophy and psychology</div><hr>Contact: <a href=mailto:ugur@rugu.dev>ugur@rugu.dev</a><hr><button class=newsletter-btn onclick='window.open("https://listmonk.rugu.dev/subscription/form","_blank")'>
Subscribe to Newsletter
</button>
<a class="source icon-container hover" href=https://github.com/kugurerdem/rugudev target=_blank><img class=icon src=/icons/git.svg>
Source Code</a></aside></div></body><html>