---
title: 'Reflections on My Journey into Software Development'
draft: false
date: '2023-09-22'
discussions:
    hackernews: https://news.ycombinator.com/item?id=37622974
tags:
    - technology
---

In the following essay, I will reflect on my journey which led me to become a
software developer.

I intend this essay to be more of a personal reflection than a technical
advisement. But whether you are a seasoned programmer or a newcomer to the
world of software development, I hope that my experiences and insights will
provide valuable guidance and inspiration for your journey.

# Before College

When I was around 6 or 7 years old, I used to hang out with my
[cousin](https://www.yuempek.com) a lot. Whenever I would see him on his
computer, he would always be engaged in something interesting like developing
recreational applications.

During those years, I had a strong interest in a game called [Solo
Test](https://en.wikipedia.org/wiki/Peg_solitaire). When I introduced the game
to my cousin, he immediately had the idea of writing code to create [this
game](http://yuempek.com/examples/javascript/solotest-Javascript.htm) on his
computer and even devloping a solution engine for it.

I witnessed the entire process of him writing lines of code and transforming
them into something visible on the computer screen. It felt like pure magic to
me. Since that moment, he has become one of my idols. Not only did he introduce
me to the concept of programming, but he also helped me explore the world of
creating games and animations with Macromedia Flash (which is no longer
supported in most browsers nowadays).

Despite my early acquaintance and interest in programming, I didn’t seriously
start learning it until high school. My attention was often consumed by other
hobbies, such as playing games, reading books, and creating pivot animations.

In high school, I started to become more aware of my analytical nature and my
inclination to approach things methodically. Even in my interest in philosophy,
I found myself more drawn to the schools of analytical philosophy rather than
continental philosophy. Given my frequent use of computers, I thought it would
be beneficial to apply my analytical tendencies to understand the tools I
already used daily, and with the guidance of my aforementioned cousin, I
decided to embark on the journey of learning programming.

I started to learn Javascript as a programming language because it was the only
programming language that could be easily executed directly in a web browser,
my cousin saw it as a great investment for the future, and the learning
resources for Javascript were readily available.

I don’t recall the exact courses I initially took to learn the syntax of
JavaScript, but I vividly remember the learning process itself. After grasping
a particular concept, I would seek guidance from my cousin on what to learn
next. He would assign me simple tasks for practice but with specific
constraints, such as not using library tools like sorting functions, string
manipulation utilities, and so on. Instead, he would usually expect me to
implement these functionalities from scratch. Despite being skeptical of this
approach, I experienced the plus of having learned things this way when I took
my first algorithm course in college. Everything was so easy on me and I could
focus on more advanced subjects like interpreter design, data structures,
programming language paradigms, and so on when my colleagues were trying to
learn the syntax of the programming language we were using.

The tasks my cousin assigned to me included writing functions that returned
strings with specific patterns and creating functions to draw lines using only
pixel-drawing utilities. I was even challenged to implement sorting algorithms
like selection sort and quick sort on my own. Some the programs I have made
during my high school days are still available on my github repositories, if
you are intereseted in them, you can check: [My Canvas Javascript
Experiments](https://kugurerdem.github.io/canvas-js-experiments/), [Javascript
Experiments](https://kugurerdem.github.io/js-experiments/), and some other
projects that I have decided for the fun of it (such as [Physics
Simulator](https://kugurerdem.github.io/physics-v0/), [Conway's Game of
Life](https://github.com/kugurerdem/conway-s-game-of-life), [Running
Game](https://kugurerdem.github.io/Running-Game/), [Text
Machine](https://kugurerdem.github.io/text-machine/), [Wolfram's Elementary
Cellular Automata](https://kugurerdem.github.io/Wolfram-s-Elementary-CA/)).

In summary, all these exercises allowed me to delve deeper into programming
concepts and sharpened my problem-solving skills. The combination of guidance
from my cousin and hands-on practice proved to be an invaluable learning
experience.

# Studying Mathematics at College

In Turkey, the universities recruit their students through a score from a
central placement exam. For this, like all other students, I was supposed to
prepare for the entrance exam if I wanted to study a profession at one of the
top universities.

When preparing for this exam, I had to interact extensively with mathematics
due to its significant influence on the test results. This, combined with my
existing interest in analytical philosophy, began to develop a greater
interest in mathematics. My initial plan was to study computer science at one
of the prestigious universities in Turkey (such as Boğaziçi, ITU, Bilkent,
ODTU) and also pursue a minor in mathematics. This way, I could satisfy my
interest in CS while maintaining my connection with mathematics, thus expanding
my options. However, various unfortunate events that occurred in my life during
my exam preparation period caused my focus to become scattered just 3-4 months
before the exam, and I couldn't dedicate myself fully to studying. In the end,
I couldn't achieve the desired score (I needed to be in the %0.1 but instead, I
was in %1), and I had to make a choice: either study CS at a mediocre
university or pursue mathematics at one of the prestigious universities
mentioned earlier while continuing my independent exploration of CS.

Fortunately, with the recommendation of a friend, I discovered that Bilkent
University, one of the top universities I mentioned above, had a highly
flexible Bachelorship of Mathematics program. Realizing that I could take
around 14 elective courses, including the compulsory electives of the CS
department, I saw an opportunity to unofficially pursue a double major with CS.
I decided to study mathematics at Bilkent University and utilize my elective
courses to take the CS department's curriculum. This turned out to be a wise
decision that I am currently satisfied with and have no regrets about.

With the decision I made above, I started taking almost all of the compulsory
CS courses except two (Operating Systems, and 4th year Algorithms course) right
from the beginning of my first semester, despite being a Mathematics major.
Even though I wouldn't have a CS diploma, I saw no problem with this because I
believed that as long as I had competence and knowledge in the subject matter,
I would have no trouble finding jobs in the software industry.

Now, looking back, I realize that my thoughts were accurate. While I can't
speak for other fields, in the realm of software development, the chances of
not finding a job despite being skilled in your area are very low. So, whether
or not you have a formal diploma isn't a significant issue as long as you excel
in your work. Of course, having a formal background in CS can bring many
advantages to your career, including as it can provide networking
opportunities, access to internships, and a structured learning environment.
However, not having one will not be the end of the world as long as you possess
a strong command of your field.

# Some of the problems I faced during College

Although I am satisfied with choosing mathematics department and progressing
from CS, it doesn't mean everything about majoring in Mathematics was perfect
and without costs.

One problem I faced was that the mathematics education often felt too pedantic
compared to other fields. This led to a loss of interest among some students,
including myself, in their major. Additionally, taking CS courses alongside Math
courses allowed me to see that the time and energy invested in the math classes
had potential opportunity costs. I realized that I could have directed that
energy toward the pursuits that are more relevant to me. The amount of energy
and time I spent on other courses like CS and Philosophy often resulted in
understanding the most important aspects, while in Mathematics, it felt more
binary - either you understood the topic as a whole or struggled with some
concepts.

Furthermore, I frequently encountered the misconception that my degree in
mathematics limits me to math-related fields such as tutoring or academia. This
highlights a lack of awareness among people about the diverse career
opportunities available to mathematics graduates. It sometimes becomes
burdensome to explain myself to others and break free from this narrow
perception.

# What values did studying Math provide to Me for Software Development

One of the important aspects of studying Mathematics is the need for caution in
our proofs. Skipping a step can undermine the validity of the entire proof. I
sometimes wonder whether this leads people who study math to not take things for
granted and be skeptical about implementation details. However, I believe that
it has certainly made me more mindful when implementing various concepts,
emphasizing the significance of considering potential errors or pitfalls and I
also believe that this skill is just as important in software development.
Similar to the caution required in mathematical proofs, being skeptical about
implementation details and not taking things for granted is vital in ensuring
the reliability of our software systems.

In addition to this, like many other majors, studying mathematics has taught me
the importance of rigorously expressing my thoughts and ideas. It has also
enhanced my endurance when it comes to handling heavy workloads. Passing most of
my math courses required substantial study efforts; it was nearly impossible to
succeed without dedicated preparation. The time required to excel in math
courses often exceeded the time needed to achieve the same grade in other
subjects. While I'm unsure if there is a direct correlation between studying
math and developing patience, I certainly believe that mathematics demands a
significant amount of patience as most mathematical concepts necessitate
prolonged concentration and attention to detail.

So is it reasonable for people who want to become programmers to study Math?
Probably not. As I mentioned earlier, while studying math can enhance one's
understanding and approach to problem-solving in many ways, the decision
ultimately depends on your willingness to invest the required effort. It's
crucial to consider the costs, especially for those who aren't interested in
learning abstract concepts. I chose to study math because I genuinely believed I
had an interest in the subject. Moreover, the university I attended provided
convenient opportunities to take computer science courses alongside it. However,
over the past two years, my enthusiasm for academic mathematics waned as my
interests shifted more toward different areas such as Computer Science.
Nonetheless, I managed to successfully graduate.

While studying math can bring benefits, I believe it should not be pursued
solely for pragmatic reasons. Otherwise, it is more likely to become a
burdensome experience rather than an enjoyable one.

# My first Works

In the last 3 years of my college (out of 5), I have started to lose my
attention regarding my degree. I think this was triggered by the COVID 19 pandemic
case, combined with my increasing interest in more pragmatic areas such as
investment, financial technologies, and my existing interest in software
development. As a result, during the COVID-19 pandemic, I shifted my focus away
from mathematics and started exploring cryptocurrencies with a friend of mine. We
learned about blockchain and decentralized finance (DeFi) and pursued
opportunities combining my programming knowledge with his research skills.

One of my first automations regarding DeFi was related to the concept of
airdrop. In the realm of decentralized finance (DeFi), an airdrop is a common
process of tokens being distributed as rewards for user engagement. What I have
done was create a script that bought tokens and sent them to various accounts
of ours in the chain to increase the amount of airdrop that we could
potentially gain. Although the project detected and addressed the activity,
despite not gaining any rewards, this experience introduced me to valuable
blockchain & programming concepts (like the patterns often used in the web3.js
library and async/await mechanisms).

We didn't just stop there. We continued to explore opportunities that could be
automated and created programs to benefit from it. Our projects included
creating an automation tool for purchasing tokens in Initial Dex Offerings
(IDOs), developing an [automated reinvesting
bot](https://github.com/kugurerdem/yakFarmer) for the [Yield Yak Auto
Compounder](https://yieldyak.com/), and crafting a [market-making
bot](https://github.com/kugurerdem/DVFBot) for [DeversiFi](https://rhino.fi/),
now known as Rhino Finance. While our work might not have been at a
professional level, these projects proved sophisticated enough to enhance our
skills and grant us the autonomy to research and explore new opportunities.
This experience was truly rewarding, as it demonstrated how my programming
knowledge could be put to practical use.

# My first Job

As I mentioned in the previous section, I began building software projects in
the pursuit of earning money even before working for someone else. This
unconventional approach eventually made acquiring my first job in the field
very easy. It all began when I was casually discussing my recent projects with
a friend, who was a CTIS student. He was surprised that I hadn't applied for a
software development job given my knowledge and skills. He
recommended me to one of his friends who was thinking about creating a startup
to make the opportunities in DeFi more accessible to traditional investors. I
underwent technical and non-technical interviews with the CEO and soon started
working as a part-time remote software developer for them.

My primary responsibility was a project I had proposed myself. I was tasked
with developing a data analytics panel and a data aggregation mechanism to
support our researchers in managing funds effectively. The autonomy I had over
this project was exciting, but it quickly became evident that the scope of the
project exceeded my experience, and the value that it would provide once it was
done didn't seem like would be able to match the effort required. This project
became my firsthand encounter with the challenges of project development; time
estimation (see: [Hofstadter's
Law](https://en.wikipedia.org/wiki/Hofstadter%27s_law)), increasing complexity
due to not knowing best practices (see: [No Silver
Bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet)), etc.

I often found myself in a place where I would want to discuss the decisions I
take while developing the project. As a result, all these experiences
emphasized the importance of having a mentor (especially in your Junior
Developer periods) in navigating such complexities.

# A new Mentor

While working at my first Job, I got the opportunity to meet with a very
[interesting person](https://gwn.wtf/mortals.html), as he likes to call himself
as well "not your usual hacker".

In one of my previous essays [Switching to Arch Linux]({{< ref
"/switching-to-archlinux" >}}) I mention how we met in a short passage as follows:

>About a year ago, I was invited to a pair coding session at the startup where
>I was working. The developers were receiving consultancy from a strange
>person. At one point, he took control of the screen sharing while reviewing
>some of the pull requests that had been made to our codebase. When he shared
>his screen, there was nothing but a black screen. Suddenly, a terminal screen
>appeared with his keystrokes and he quickly began examining the codebase,
>providing feedback on people’s code at a speed I had never seen before. He was
>able to jump between different files in an instant, examining the diffs that
>were made in different git commits.

>After seeing what I saw, I thought to myself, ‘If I were able to develop and
>refactor code at that speed, I would save a lot of time, I could have spent
>more time thinking about the actual stuff with as little friction as possible.
>I want to have this power.’ So I have looked at his CV and realized that he was
>knowledgeable on topics that many developers, including myself, struggle with.
>Influenced by this, I started asking him (he was our consultant, after all) as
>many questions as I could and focused on the resources he suggested and the
>technologies he used.

From that point on, I began to frequently ask him questions about software
development and seek his guidance. Luckily, he was usually more than willing to
answer my questions. At some point, we admired each other’s thinking style and
approach to software development so much that we even started working together
on several projects, which have continued for a year now.

Whether it's related to software development or not, I consider having a mentor
to be a significant advantage for improvement. When it comes to
learning basic concepts like programming languages and certain frameworks,
which are well-documented, having a mentor may not matter much. However, when
dealing with complex problems that require interpretation, experience, and a
nuanced approach, having a mentor, or at least an advisor, becomes crucial.

I view mentors as a means of gaining refined knowledge, especially in areas
where I could potentially stumble into common pitfalls, which could otherwise
cost me a significant amount of time.

Mentors, like all things, can be good or bad. A mentor is good if they:

- Want to teach you how to fish instead of merely handing you a fish. This
  teaching approach may involve providing you with essential keywords to search
  for solutions to your problems or, at times, demonstrating their methods
  and approaches through concepts like pair programming, acquainting you with
  effective problem-solving techniques.
- Give constructive criticism, and they do so by explaining the reasoning
  behind their assessments of your achievements. This not only helps you
  understand your areas of improvement but also encourages a deeper
  comprehension of your work.
- Maintain an open attitude toward new questions. They create an environment
  where you feel comfortable seeking guidance, knowing that they are genuinely
  interested in assisting your growth and development.

In my journey as a software developer, From [yuempek](http://yuempek.com) to
[gwn](https://gwn.wtf/mortals.html). Whenever I've come across a new concept or
a challenging problem that needs a unique solution, seeking the advice of more
experienced individuals has been incredibly helpful.

The bottom line is if you want to improve your skills as a software developer
and do it quickly, having a mentor is essential. They offer insights,
perspectives, and expertise that can speed up your progress and help you
navigate the complexities of the field more effectively.

# In Summary

Here are some of the claims I would make based on my computer science journey
so far:

- When it comes to learning stuff, don't ever shy away from getting your hands
  dirty. You cannot just improve just by watching people doing stuff, after
  learning new concepts regarding any programming language or so always try to
  think about what things you can achieve with the limited tools you have at
  your hand. You will be surprised how many things can be accomplished even
  with very fundamental stuff. My initial learning process regarding
  programming was just like this, I would usually just try to execute one of
  the random ideas that would come which can be accomplished just with the tool
  I have learned.

- Whether it's a small or large project, archive them in a place where you can
  access them later. If possible, you can even make them public on platforms
  like GitHub or similar platforms. This will not only motivate you to expand
  your collection of your programs but also enable you to track your
  progress. It's a highly satisfying experience to be able to see and showcase
  the first programs you have written.

- If you are pursuing a degree other than computer science, it's important not
  to overestimate the value of a formal computer science education. While such
  an education certainly has its advantages, like providing a strong foundation
  in theoretical concepts and algorithms, as well as granting you a legitimate
  certificate of graduation that signals your proficiency in these subjects,
  not having a CS degree will not hinder your entry into the software industry.
  As long as you can demonstrate your ability to complete tasks effectively,
  people will be interested in hiring you. Whether you hold a degree or not, if
  you possess the determination and passion required, doors will likely open
  for you in the software industry.

- Seek mentorship. Learn from those with refined experience. It will
  significantly speed up your learning pace, especially when trying to
  understand non-trivial stuff. However, keep in mind that the qualities of
  your mentor also matter a lot. What I often see is that smart people, just
  like in other areas as well, are usually better at picking the mentor of
  their interests as well. It is not just important to have a mentor but also
  to have a mentor that suits your taste, otherwise, a bad mentor with whom you
  spent time might come at the cost of a better one.
